package sc.small.chat.global.security.filter;import static org.springframework.http.HttpHeaders.AUTHORIZATION;import jakarta.servlet.FilterChain;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import sc.small.chat.global.security.service.JwtProvider;@Slf4j@RequiredArgsConstructorpublic class JwtAuthenticationFilter extends OncePerRequestFilter {    private final JwtProvider jwtProvider;    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {        String accessToken = jwtProvider.resolveToken(request);        // accessToken 검증        if (jwtProvider.validateToken(accessToken)) {            setAuthentication(accessToken);        } else {            // 만료되었을 경우 accessToken 재발급            String reissueAccessToken = jwtProvider.reissueAccessToken(accessToken);            if (StringUtils.hasText(reissueAccessToken)) {                setAuthentication(reissueAccessToken);                // 재발급된 accessToken 다시 전달                response.setHeader(AUTHORIZATION, "Bearer " + reissueAccessToken);            }        }        filterChain.doFilter(request, response);    }    private void setAuthentication(String accessToken) {        // 토큰이 유효할 경우 토큰에서 Authentication 객체를 가지고 와서 SecurityContext 에 저장, 즉 디비를 거치지 않음        Authentication authentication = jwtProvider.getAuthentication(accessToken);        SecurityContextHolder.getContext().setAuthentication(authentication);    }}