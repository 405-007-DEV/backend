package sc.small.chat.global.aop;import java.util.HashMap;import java.util.Map;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.validation.BindingResult;import sc.small.chat.global.exception.SmallChatHttpException;@Aspect@Component@Order(1)public class ValidationAOP {    private final Logger logger = LoggerFactory.getLogger(ValidationAOP.class);    @Pointcut("@annotation(sc.small.chat.global.annotaion.ValidateDTO)")    public void validateDTO() {        // Pointcut for methods annotated with @ValidateDTO    }    @Around("validateDTO()")    public Object validateDTOAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        for (Object arg : proceedingJoinPoint.getArgs()) {            if (arg instanceof BindingResult) {                BindingResult bindingResult = (BindingResult) arg;                if (bindingResult.hasErrors()) {                    Map<String, String> errorMap = new HashMap<>();                    bindingResult.getFieldErrors().forEach(error ->                        errorMap.put(error.getField(), error.getDefaultMessage() != null ? error.getDefaultMessage() : "")                    );                    throw new SmallChatHttpException(HttpStatus.BAD_REQUEST, errorMap.toString());                }            }        }        return proceedingJoinPoint.proceed();  // Proceed with the method execution if validation passes    }}