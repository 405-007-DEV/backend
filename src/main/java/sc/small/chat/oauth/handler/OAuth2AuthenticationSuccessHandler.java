package sc.small.chat.oauth.handler;import static sc.small.chat.oauth.repository.OAuth2AuthorizationRequestBasedOnCookieRepository.REDIRECT_URI_PARAM_COOKIE_NAME;import static sc.small.chat.oauth.repository.OAuth2AuthorizationRequestBasedOnCookieRepository.REFRESH_TOKEN;import static sc.small.chat.global.security.service.JwtTokenProvider.getRefreshTokenExpireTimeCookie;import jakarta.servlet.http.Cookie;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URI;import java.util.Collection;import java.util.Optional;import java.util.concurrent.TimeUnit;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;import org.springframework.security.oauth2.core.oidc.user.OidcUser;import org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler;import org.springframework.stereotype.Component;import org.springframework.web.util.UriComponentsBuilder;import sc.small.chat.oauth.util.OAuth2UserInfo;import sc.small.chat.oauth.enums.ProviderType;import sc.small.chat.oauth.repository.OAuth2AuthorizationRequestBasedOnCookieRepository;import sc.small.chat.oauth.util.CookieUtil;import sc.small.chat.oauth.util.OAuth2UserInfoUtil;import sc.small.chat.global.dto.TokenInfoDTO;import sc.small.chat.global.security.service.JwtTokenProvider;@Slf4j@Component@RequiredArgsConstructorpublic class OAuth2AuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {    @Value("${app.oauth2.authorized-redirect-uris}")    private String redirectUri;    private final OAuth2AuthorizationRequestBasedOnCookieRepository authorizationRequestRepository;    private final JwtTokenProvider jwtTokenProvider;    private final RedisTemplate<String, String> redisTemplate;    @Override    public void onAuthenticationSuccess(        HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {        String targetUrl = determineTargetUrl(request, response, authentication);        if (response.isCommitted()) {            log.error("Response has already been committed. Unable to redirect to " + targetUrl);            return;        }        clearAuthenticationAttributes(request, response);        getRedirectStrategy().sendRedirect(request, response, targetUrl);    }    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {        Optional<String> redirectUri = CookieUtil.getCookie(request, REDIRECT_URI_PARAM_COOKIE_NAME)            .map(Cookie::getValue);        if (redirectUri.isPresent() && !isAuthorizedRedirectUri(redirectUri.get())) {            log.error("determineTargetUrl - redirectUri : {} , 인증을 진행할 수 없습니다.", redirectUri);            throw new IllegalArgumentException("Sorry! We've got an Unauthorized Redirect URI and can't proceed with the authentication");        }        String targetUrl = redirectUri.orElse(getDefaultTargetUrl());        OAuth2AuthenticationToken authToken = (OAuth2AuthenticationToken) authentication;        ProviderType providerType = ProviderType.valueOf(authToken.getAuthorizedClientRegistrationId().toUpperCase());        OidcUser user = ((OidcUser) authentication.getPrincipal());        OAuth2UserInfo userInfo = OAuth2UserInfoUtil.getOAuth2UserInfo(providerType, user.getAttributes());        TokenInfoDTO tokenInfo = jwtTokenProvider.generateToken(userInfo);        redisTemplate.opsForValue()            .set("RT:" + authentication.getName(), tokenInfo.getRefreshToken(), tokenInfo.getRefreshTokenExpirationTime(), TimeUnit.MILLISECONDS);        CookieUtil.deleteCookie(request, response, REFRESH_TOKEN);        CookieUtil.addCookie(response, REFRESH_TOKEN, tokenInfo.getRefreshToken(), getRefreshTokenExpireTimeCookie());        return UriComponentsBuilder.fromUriString(targetUrl)            .queryParam("accessToken", tokenInfo.getAccessToken())            .queryParam("refreshToken", tokenInfo.getRefreshToken())            .build().toUriString();    }    protected void clearAuthenticationAttributes(HttpServletRequest request, HttpServletResponse response) {        super.clearAuthenticationAttributes(request);        authorizationRequestRepository.removeAuthorizationRequestCookies(request, response);    }    private boolean hasAuthority(Collection<? extends GrantedAuthority> authorities, String authority) {        if (authorities == null) {            return false;        }        for (GrantedAuthority grantedAuthority : authorities) {            if (authority.equals(grantedAuthority.getAuthority())) {                return true;            }        }        return false;    }    private boolean isAuthorizedRedirectUri(String uri) {        URI clientRedirectUri = URI.create(uri);        URI authorizedUri = URI.create(redirectUri);        return authorizedUri.getHost().equalsIgnoreCase(clientRedirectUri.getHost())            && authorizedUri.getPort() == clientRedirectUri.getPort();    }}